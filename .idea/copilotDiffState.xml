<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/data/auth/ApiClient.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/data/auth/ApiClient.kt" />
              <option name="originalContent" value="package com.example.data.auth&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import com.google.gson.Gson&#10;import com.google.gson.GsonBuilder&#10;import okhttp3.Authenticator&#10;import okhttp3.Interceptor&#10;import okhttp3.MediaType.Companion.toMediaType&#10;import okhttp3.OkHttpClient&#10;import okhttp3.Request&#10;import okhttp3.RequestBody.Companion.toRequestBody&#10;import okhttp3.Response&#10;import okhttp3.Route&#10;import okhttp3.logging.HttpLoggingInterceptor&#10;import retrofit2.converter.gson.GsonConverterFactory&#10;import java.io.IOException&#10;import java.util.UUID&#10;import java.util.concurrent.TimeUnit&#10;&#10;object ApiClient {&#10;    fun create(context: Context, baseUrl: String): com.example.data.auth.ApiService {&#10;        val logger = HttpLoggingInterceptor().apply { level = HttpLoggingInterceptor.Level.BODY }&#10;&#10;        // Interceptor para trazar peticiones con un UUID y log en Logcat&#10;        val traceInterceptor = Interceptor { chain -&gt;&#10;            val req = chain.request()&#10;            val id = UUID.randomUUID().toString()&#10;            val newReq = req.newBuilder()&#10;                .addHeader(&quot;X-Request-Id&quot;, id)&#10;                .addHeader(&quot;X-Request-From-App&quot;, &quot;true&quot;)&#10;                .build()&#10;&#10;            Log.d(&quot;ApiClient-Request&quot;, &quot;id=$id method=${newReq.method} url=${newReq.url}&quot;)&#10;&#10;            val resp = chain.proceed(newReq)&#10;&#10;            Log.d(&quot;ApiClient-Request&quot;, &quot;id=$id response=${resp.code} for ${newReq.url}&quot;)&#10;            resp&#10;        }&#10;&#10;        val authInterceptor = Interceptor { chain -&gt;&#10;            val req = chain.request()&#10;            // No añadir Authorization para endpoints de auth (login/refresh/oauth)&#10;            val path = req.url.encodedPath&#10;            if (path.contains(&quot;/api/auth/login&quot;) || path.contains(&quot;/api/auth/refresh&quot;) || path.contains(&quot;/api/auth/oauth/&quot;)) {&#10;                return@Interceptor chain.proceed(req)&#10;            }&#10;&#10;            val reqBuilder = req.newBuilder()&#10;            val token = com.example.data.auth.TokenStorage.getAccessToken(context)&#10;            if (!token.isNullOrEmpty()) {&#10;                reqBuilder.addHeader(&quot;Authorization&quot;, &quot;Bearer $token&quot;)&#10;            }&#10;            chain.proceed(reqBuilder.build())&#10;        }&#10;&#10;        val authenticator = object : Authenticator {&#10;            // Cuenta cuántas respuestas previas hubo para evitar reintentos infinitos&#10;            private fun responseCount(response: Response?): Int {&#10;                var res = response&#10;                var result = 1&#10;                while (res?.priorResponse != null) {&#10;                    result++&#10;                    res = res.priorResponse&#10;                }&#10;                return result&#10;            }&#10;&#10;            override fun authenticate(route: Route?, response: Response): Request? {&#10;                Log.d(&quot;ApiClient-Auth&quot;, &quot;authenticate called: code=${response.code} url=${response.request.url}&quot;)&#10;&#10;                // Sólo intentamos refresh para 401 (no para 400/403/5xx)&#10;                if (response.code != 401) {&#10;                    Log.d(&quot;ApiClient-Auth&quot;, &quot;not 401 -&gt; no refresh&quot;)&#10;                    return null&#10;                }&#10;&#10;                // Si no había un header Authorization en la petición original, no intentamos refresh&#10;                if (response.request.header(&quot;Authorization&quot;) == null) {&#10;                    Log.d(&quot;ApiClient-Auth&quot;, &quot;original request had no Authorization header -&gt; no refresh&quot;)&#10;                    return null&#10;                }&#10;&#10;                // Evitar bucles: si ya intentamos al menos una vez, no reintentar&#10;                val count = responseCount(response)&#10;                Log.d(&quot;ApiClient-Auth&quot;, &quot;prior response count=$count&quot;)&#10;                if (count &gt;= 2) {&#10;                    Log.w(&quot;ApiClient&quot;, &quot;authenticate: already attempted to authenticate, giving up&quot;)&#10;                    return null&#10;                }&#10;&#10;                // No intentar refresh si la petición original era al endpoint de login, refresh u oauth&#10;                val originalUrl = response.request.url.encodedPath&#10;                if (originalUrl.contains(&quot;/api/auth/login&quot;) || originalUrl.contains(&quot;/api/auth/refresh&quot;) || originalUrl.contains(&quot;/api/auth/oauth/&quot;)) {&#10;                    Log.w(&quot;ApiClient&quot;, &quot;authenticate: not refreshing token for auth endpoints: $originalUrl&quot;)&#10;                    return null&#10;                }&#10;&#10;                val refresh = com.example.data.auth.TokenStorage.getRefreshToken(context)&#10;                if (refresh.isNullOrEmpty()) {&#10;                    Log.d(&quot;ApiClient-Auth&quot;, &quot;no refresh token available -&gt; clearing tokens and abort&quot;)&#10;                    com.example.data.auth.TokenStorage.clear(context)&#10;                    return null&#10;                }&#10;&#10;                try {&#10;                    // Build a simple OkHttpClient without authenticator to call refresh endpoint synchronously&#10;                    val client = OkHttpClient.Builder()&#10;                        .connectTimeout(15, TimeUnit.SECONDS)&#10;                        .readTimeout(15, TimeUnit.SECONDS)&#10;                        .build()&#10;&#10;                    val json = &quot;{\&quot;refreshToken\&quot;:\&quot;${refresh}\&quot;}&quot;&#10;                    val body = json.toRequestBody(&quot;application/json; charset=utf-8&quot;.toMediaType())&#10;                    val req = Request.Builder()&#10;                        .url(baseUrl.trimEnd('/') + &quot;/api/auth/refresh&quot;)&#10;                        .post(body)&#10;                        .build()&#10;&#10;                    val resp = client.newCall(req).execute()&#10;&#10;                    Log.d(&quot;ApiClient-Auth&quot;, &quot;refresh request returned code=${resp.code}&quot;)&#10;&#10;                    if (!resp.isSuccessful) {&#10;                        Log.w(&quot;ApiClient-Auth&quot;, &quot;refresh failed -&gt; clearing tokens&quot;)&#10;                        com.example.data.auth.TokenStorage.clear(context)&#10;                        return null&#10;                    }&#10;&#10;                    val gson: Gson = GsonBuilder().create()&#10;                    val respBody = resp.body?.string() ?: run {&#10;                        Log.w(&quot;ApiClient-Auth&quot;, &quot;refresh response had empty body -&gt; clearing tokens&quot;)&#10;                        com.example.data.auth.TokenStorage.clear(context)&#10;                        return null&#10;                    }&#10;&#10;                    Log.d(&quot;ApiClient-Auth&quot;, &quot;refresh response body=$respBody&quot;)&#10;&#10;                    val refreshResp = gson.fromJson(respBody, com.example.data.auth.RefreshResponse::class.java)&#10;                    val newAccess = refreshResp?.accessTokenNormalized&#10;                    if (newAccess.isNullOrEmpty()) {&#10;                        Log.w(&quot;ApiClient-Auth&quot;, &quot;refresh response missing access token -&gt; clearing tokens&quot;)&#10;                        com.example.data.auth.TokenStorage.clear(context)&#10;                        return null&#10;                    }&#10;&#10;                    com.example.data.auth.TokenStorage.setAccessToken(context, newAccess)&#10;&#10;                    // Retry original request with new token&#10;                    Log.d(&quot;ApiClient-Auth&quot;, &quot;refresh succeeded, retrying original request with new token&quot;)&#10;                    return response.request.newBuilder()&#10;                        .header(&quot;Authorization&quot;, &quot;Bearer $newAccess&quot;)&#10;                        .build()&#10;&#10;                } catch (ex: IOException) {&#10;                    Log.e(&quot;ApiClient&quot;, &quot;refresh token failed&quot;, ex)&#10;                    com.example.data.auth.TokenStorage.clear(context)&#10;                    return null&#10;                }&#10;            }&#10;        }&#10;&#10;        val client = OkHttpClient.Builder()&#10;            .addInterceptor(traceInterceptor)&#10;            .addInterceptor(logger)&#10;            .addInterceptor(authInterceptor)&#10;            .authenticator(authenticator)&#10;            .connectTimeout(30, TimeUnit.SECONDS)&#10;            .readTimeout(30, TimeUnit.SECONDS)&#10;            // Evitar redirecciones automáticas y reintentos que pueden crear bucles y multiplicar requests&#10;            .followRedirects(false)&#10;            .followSslRedirects(false)&#10;            .retryOnConnectionFailure(false)&#10;            .build()&#10;&#10;        val gson: Gson = GsonBuilder().create()&#10;        val retrofit = retrofit2.Retrofit.Builder()&#10;            .baseUrl(baseUrl)&#10;            .client(client)&#10;            .addConverterFactory(GsonConverterFactory.create(gson))&#10;            .build()&#10;&#10;        return retrofit.create(com.example.data.auth.ApiService::class.java)&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.data.auth&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import com.example.facturacion_inventario.BuildConfig&#10;import com.google.gson.Gson&#10;import com.google.gson.GsonBuilder&#10;import okhttp3.Authenticator&#10;import okhttp3.Interceptor&#10;import okhttp3.MediaType.Companion.toMediaType&#10;import okhttp3.OkHttpClient&#10;import okhttp3.Request&#10;import okhttp3.RequestBody.Companion.toRequestBody&#10;import okhttp3.Response&#10;import okhttp3.Route&#10;import okhttp3.logging.HttpLoggingInterceptor&#10;import retrofit2.converter.gson.GsonConverterFactory&#10;import java.io.IOException&#10;import java.util.UUID&#10;import java.util.concurrent.TimeUnit&#10;&#10;object ApiClient {&#10;    fun create(context: Context, baseUrl: String): ApiService {&#10;        val logger = HttpLoggingInterceptor().apply {&#10;            level = if (BuildConfig.DEBUG) HttpLoggingInterceptor.Level.BODY&#10;            else HttpLoggingInterceptor.Level.NONE&#10;        }&#10;&#10;        // Interceptor para trazar peticiones con un UUID y log en Logcat&#10;        val traceInterceptor = Interceptor { chain -&gt;&#10;            val req = chain.request()&#10;            val id = UUID.randomUUID().toString()&#10;            val newReq = req.newBuilder()&#10;                .addHeader(&quot;X-Request-Id&quot;, id)&#10;                .addHeader(&quot;X-Request-From-App&quot;, &quot;true&quot;)&#10;                .build()&#10;&#10;            if (BuildConfig.DEBUG) Log.d(&quot;ApiClient-Request&quot;, &quot;id=$id method=${newReq.method} url=${newReq.url}&quot;)&#10;&#10;            val resp = chain.proceed(newReq)&#10;&#10;            if (BuildConfig.DEBUG) Log.d(&quot;ApiClient-Request&quot;, &quot;id=$id response=${resp.code} for ${newReq.url}&quot;)&#10;            resp&#10;        }&#10;&#10;        val authInterceptor = Interceptor { chain -&gt;&#10;            val req = chain.request()&#10;            // No añadir Authorization para endpoints de auth (login/refresh/oauth)&#10;            val path = req.url.encodedPath&#10;            if (path.contains(&quot;/api/auth/login&quot;) || path.contains(&quot;/api/auth/refresh&quot;) || path.contains(&quot;/api/auth/oauth/&quot;)) {&#10;                return@Interceptor chain.proceed(req)&#10;            }&#10;&#10;            val reqBuilder = req.newBuilder()&#10;            val token = TokenStorage.getAccessToken(context)&#10;            if (!token.isNullOrEmpty()) {&#10;                reqBuilder.addHeader(&quot;Authorization&quot;, &quot;Bearer $token&quot;)&#10;            }&#10;            chain.proceed(reqBuilder.build())&#10;        }&#10;&#10;        val authenticator = object : Authenticator {&#10;            // Cuenta cuántas respuestas previas hubo para evitar reintentos infinitos&#10;            private fun responseCount(response: Response?): Int {&#10;                var res = response&#10;                var result = 1&#10;                while (res?.priorResponse != null) {&#10;                    result++&#10;                    res = res.priorResponse&#10;                }&#10;                return result&#10;            }&#10;&#10;            override fun authenticate(route: Route?, response: Response): Request? {&#10;                if (BuildConfig.DEBUG) Log.d(&quot;ApiClient-Auth&quot;, &quot;authenticate called: code=${response.code} url=${response.request.url}&quot;)&#10;&#10;                // Sólo intentamos refresh para 401 (no para 400/403/5xx)&#10;                if (response.code != 401) {&#10;                    if (BuildConfig.DEBUG) Log.d(&quot;ApiClient-Auth&quot;, &quot;not 401 -&gt; no refresh&quot;)&#10;                    return null&#10;                }&#10;&#10;                // Si no había un header Authorization en la petición original, no intentamos refresh&#10;                if (response.request.header(&quot;Authorization&quot;) == null) {&#10;                    if (BuildConfig.DEBUG) Log.d(&quot;ApiClient-Auth&quot;, &quot;original request had no Authorization header -&gt; no refresh&quot;)&#10;                    return null&#10;                }&#10;&#10;                // Evitar bucles: si ya intentamos al menos una vez, no reintentar&#10;                val count = responseCount(response)&#10;                if (BuildConfig.DEBUG) Log.d(&quot;ApiClient-Auth&quot;, &quot;prior response count=$count&quot;)&#10;                if (count &gt;= 2) {&#10;                    Log.w(&quot;ApiClient&quot;, &quot;authenticate: already attempted to authenticate, giving up&quot;)&#10;                    return null&#10;                }&#10;&#10;                // No intentar refresh si la petición original era al endpoint de login, refresh u oauth&#10;                val originalUrl = response.request.url.encodedPath&#10;                if (originalUrl.contains(&quot;/api/auth/login&quot;) || originalUrl.contains(&quot;/api/auth/refresh&quot;) || originalUrl.contains(&quot;/api/auth/oauth/&quot;)) {&#10;                    Log.w(&quot;ApiClient&quot;, &quot;authenticate: not refreshing token for auth endpoints: $originalUrl&quot;)&#10;                    return null&#10;                }&#10;&#10;                val refresh = TokenStorage.getRefreshToken(context)&#10;                if (refresh.isNullOrEmpty()) {&#10;                    if (BuildConfig.DEBUG) Log.d(&quot;ApiClient-Auth&quot;, &quot;no refresh token available -&gt; clearing tokens and abort&quot;)&#10;                    TokenStorage.clear(context)&#10;                    return null&#10;                }&#10;&#10;                try {&#10;                    // Build a simple OkHttpClient without authenticator to call refresh endpoint synchronously&#10;                    val client = OkHttpClient.Builder()&#10;                        .connectTimeout(15, TimeUnit.SECONDS)&#10;                        .readTimeout(15, TimeUnit.SECONDS)&#10;                        .build()&#10;&#10;                    val json = &quot;{\&quot;refreshToken\&quot;:\&quot;${refresh}\&quot;}&quot;&#10;                    val body = json.toRequestBody(&quot;application/json; charset=utf-8&quot;.toMediaType())&#10;                    val req = Request.Builder()&#10;                        .url(baseUrl.trimEnd('/') + &quot;/api/auth/refresh&quot;)&#10;                        .post(body)&#10;                        .build()&#10;&#10;                    val resp = client.newCall(req).execute()&#10;&#10;                    if (BuildConfig.DEBUG) Log.d(&quot;ApiClient-Auth&quot;, &quot;refresh request returned code=${resp.code}&quot;)&#10;&#10;                    if (!resp.isSuccessful) {&#10;                        Log.w(&quot;ApiClient-Auth&quot;, &quot;refresh failed -&gt; clearing tokens&quot;)&#10;                        TokenStorage.clear(context)&#10;                        return null&#10;                    }&#10;&#10;                    val gson: Gson = GsonBuilder().create()&#10;                    val respBody = resp.body?.string() ?: run {&#10;                        Log.w(&quot;ApiClient-Auth&quot;, &quot;refresh response had empty body -&gt; clearing tokens&quot;)&#10;                        TokenStorage.clear(context)&#10;                        return null&#10;                    }&#10;&#10;                    // No loguear el cuerpo completo en producción; sólo en debug&#10;                    if (BuildConfig.DEBUG) Log.d(&quot;ApiClient-Auth&quot;, &quot;refresh response body(length=${respBody.length})&quot;)&#10;&#10;                    val refreshResp = gson.fromJson(respBody, RefreshResponse::class.java)&#10;                    val newAccess = refreshResp?.accessTokenNormalized&#10;                    if (newAccess.isNullOrEmpty()) {&#10;                        Log.w(&quot;ApiClient-Auth&quot;, &quot;refresh response missing access token -&gt; clearing tokens&quot;)&#10;                        TokenStorage.clear(context)&#10;                        return null&#10;                    }&#10;&#10;                    TokenStorage.setAccessToken(context, newAccess)&#10;&#10;                    // Retry original request with new token&#10;                    if (BuildConfig.DEBUG) Log.d(&quot;ApiClient-Auth&quot;, &quot;refresh succeeded, retrying original request with new token&quot;)&#10;                    return response.request.newBuilder()&#10;                        .header(&quot;Authorization&quot;, &quot;Bearer $newAccess&quot;)&#10;                        .build()&#10;&#10;                } catch (ex: IOException) {&#10;                    Log.e(&quot;ApiClient&quot;, &quot;refresh token failed&quot;, ex)&#10;                    TokenStorage.clear(context)&#10;                    return null&#10;                }&#10;            }&#10;        }&#10;&#10;        val client = OkHttpClient.Builder()&#10;            .addInterceptor(traceInterceptor)&#10;            .addInterceptor(logger)&#10;            .addInterceptor(authInterceptor)&#10;            .authenticator(authenticator)&#10;            .connectTimeout(30, TimeUnit.SECONDS)&#10;            .readTimeout(30, TimeUnit.SECONDS)&#10;            // Evitar redirecciones automáticas y reintentos que pueden crear bucles y multiplicar requests&#10;            .followRedirects(false)&#10;            .followSslRedirects(false)&#10;            .retryOnConnectionFailure(false)&#10;            .build()&#10;&#10;        val gson: Gson = GsonBuilder().create()&#10;        val retrofit = retrofit2.Retrofit.Builder()&#10;            .baseUrl(baseUrl)&#10;            .client(client)&#10;            .addConverterFactory(GsonConverterFactory.create(gson))&#10;            .build()&#10;&#10;        return retrofit.create(ApiService::class.java)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/facturacion_inventario/data/remote/api/RetrofitClient.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/facturacion_inventario/data/remote/api/RetrofitClient.kt" />
              <option name="originalContent" value="package com.example.facturacion_inventario.data.remote.api&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import com.example.data.auth.ApiConfig&#10;import com.example.data.auth.TokenStorage&#10;import com.google.gson.GsonBuilder&#10;import okhttp3.Interceptor&#10;import okhttp3.OkHttpClient&#10;import okhttp3.logging.HttpLoggingInterceptor&#10;import retrofit2.Retrofit&#10;import retrofit2.converter.gson.GsonConverterFactory&#10;import java.util.concurrent.TimeUnit&#10;&#10;/**&#10; * Cliente Retrofit singleton para la API de productos, categorías y carritos&#10; * Ahora incluye autenticación JWT para evitar errores 401&#10; */&#10;object RetrofitClient {&#10;&#10;    private var context: Context? = null&#10;    private const val TAG = &quot;RetrofitAuth&quot;&#10;&#10;    /**&#10;     * Inicializa el cliente con el contexto de la aplicación&#10;     * Llamar desde Application o MainActivity&#10;     */&#10;    fun initialize(appContext: Context) {&#10;        context = appContext.applicationContext&#10;    }&#10;&#10;    private val loggingInterceptor = HttpLoggingInterceptor().apply {&#10;        level = HttpLoggingInterceptor.Level.BODY&#10;    }&#10;&#10;    /**&#10;     * Interceptor defensivo: elimina header Authorization en rutas públicas&#10;     */&#10;    private val stripAuthInterceptor = Interceptor { chain -&gt;&#10;        val req = chain.request()&#10;        val path = req.url.encodedPath&#10;        if (path.contains(&quot;/api/public/&quot;)) {&#10;            val stripped = req.newBuilder().removeHeader(&quot;Authorization&quot;).build()&#10;            Log.d(TAG, &quot;Stripping Authorization header for public path: $path&quot;)&#10;            return@Interceptor chain.proceed(stripped)&#10;        }&#10;        chain.proceed(req)&#10;    }&#10;&#10;    /**&#10;     * Interceptor de autenticación que agrega el token JWT&#10;     */&#10;    private val authInterceptor = Interceptor { chain -&gt;&#10;        val req = chain.request()&#10;        val path = req.url.encodedPath&#10;&#10;        // No agregar token a endpoints públicos (auth, uploads públicos, etc.)&#10;        if (path.contains(&quot;/api/auth/&quot;) || path.contains(&quot;/api/public/&quot;)) {&#10;            Log.d(TAG, &quot;Skipping auth header for public path: $path&quot;)&#10;            return@Interceptor chain.proceed(req)&#10;        }&#10;&#10;        val reqBuilder = req.newBuilder()&#10;        context?.let { ctx -&gt;&#10;            val token = TokenStorage.getAccessToken(ctx)&#10;            if (!token.isNullOrEmpty()) {&#10;                Log.d(TAG, &quot;Adding Authorization header for path: $path&quot;)&#10;                reqBuilder.addHeader(&quot;Authorization&quot;, &quot;Bearer $token&quot;)&#10;            } else {&#10;                Log.d(TAG, &quot;No token found; proceeding without Authorization for path: $path&quot;)&#10;            }&#10;        } ?: run {&#10;            Log.d(TAG, &quot;Context null; proceeding without Authorization for path: $path&quot;)&#10;        }&#10;        val newReq = reqBuilder.build()&#10;        // Log headers for debugging (avoid printing token itself)&#10;        Log.d(TAG, &quot;Request to $path headers=${newReq.headers}&quot;)&#10;        chain.proceed(newReq)&#10;    }&#10;&#10;    private val okHttpClient = OkHttpClient.Builder()&#10;        .addInterceptor(loggingInterceptor)&#10;        .addInterceptor(stripAuthInterceptor)&#10;        .addInterceptor(authInterceptor)&#10;        .connectTimeout(30, TimeUnit.SECONDS)&#10;        .readTimeout(30, TimeUnit.SECONDS)&#10;        .writeTimeout(30, TimeUnit.SECONDS)&#10;        .build()&#10;&#10;    private val gson = GsonBuilder()&#10;        .setDateFormat(&quot;yyyy-MM-dd'T'HH:mm:ss.SSSZ&quot;)&#10;        .setLenient()&#10;        .create()&#10;&#10;    private val retrofit: Retrofit by lazy {&#10;        Retrofit.Builder()&#10;            .baseUrl(ApiConfig.BASE_URL)&#10;            .client(okHttpClient)&#10;            .addConverterFactory(GsonConverterFactory.create(gson))&#10;            .build()&#10;    }&#10;&#10;    val productoApiService: ProductoApiService by lazy {&#10;        retrofit.create(ProductoApiService::class.java)&#10;    }&#10;&#10;    val categoriaApiService: CategoriaApiService by lazy {&#10;        retrofit.create(CategoriaApiService::class.java)&#10;    }&#10;&#10;    val carritoApiService: CarritoApiService by lazy {&#10;        retrofit.create(CarritoApiService::class.java)&#10;    }&#10;&#10;    val facturaApiService: FacturaApiService by lazy {&#10;        retrofit.create(FacturaApiService::class.java)&#10;    }&#10;&#10;    val stockApiService: StockApiService by lazy {&#10;        retrofit.create(StockApiService::class.java)&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.facturacion_inventario.data.remote.api&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import com.example.data.auth.ApiConfig&#10;import com.example.data.auth.TokenStorage&#10;import com.google.gson.GsonBuilder&#10;import okhttp3.Interceptor&#10;import okhttp3.OkHttpClient&#10;import okhttp3.logging.HttpLoggingInterceptor&#10;import retrofit2.Retrofit&#10;import retrofit2.converter.gson.GsonConverterFactory&#10;import java.util.concurrent.TimeUnit&#10;&#10;/**&#10; * Cliente Retrofit singleton para la API de productos, categorías y carritos&#10; * Ahora incluye autenticación JWT para evitar errores 401&#10; */&#10;object RetrofitClient {&#10;&#10;    private var context: Context? = null&#10;    private const val TAG = &quot;RetrofitAuth&quot;&#10;&#10;    /**&#10;     * Inicializa el cliente con el contexto de la aplicación&#10;     * Llamar desde Application o MainActivity&#10;     */&#10;    fun initialize(appContext: Context) {&#10;        context = appContext.applicationContext&#10;    }&#10;&#10;    private val loggingInterceptor = HttpLoggingInterceptor().apply {&#10;        level = HttpLoggingInterceptor.Level.BODY&#10;    }&#10;&#10;    /**&#10;     * Interceptor defensivo: elimina header Authorization en rutas públicas&#10;     */&#10;    private val stripAuthInterceptor = Interceptor { chain -&gt;&#10;        val req = chain.request()&#10;        val path = req.url.encodedPath&#10;        if (path.contains(&quot;/api/public/&quot;)) {&#10;            val stripped = req.newBuilder().removeHeader(&quot;Authorization&quot;).build()&#10;            Log.d(TAG, &quot;Stripping Authorization header for public path: $path&quot;)&#10;            return@Interceptor chain.proceed(stripped)&#10;        }&#10;        chain.proceed(req)&#10;    }&#10;&#10;    /**&#10;     * Interceptor de autenticación que agrega el token JWT&#10;     */&#10;    private val authInterceptor = Interceptor { chain -&gt;&#10;        val req = chain.request()&#10;        val path = req.url.encodedPath&#10;&#10;        // No agregar token a endpoints públicos (auth, uploads públicos, etc.)&#10;        if (path.contains(&quot;/api/auth/&quot;) || path.contains(&quot;/api/public/&quot;)) {&#10;            Log.d(TAG, &quot;Skipping auth header for public path: $path&quot;)&#10;            return@Interceptor chain.proceed(req)&#10;        }&#10;&#10;        val reqBuilder = req.newBuilder()&#10;        context?.let { ctx -&gt;&#10;            val token = TokenStorage.getAccessToken(ctx)&#10;            if (!token.isNullOrEmpty()) {&#10;                Log.d(TAG, &quot;Adding Authorization header for path: $path&quot;)&#10;                reqBuilder.addHeader(&quot;Authorization&quot;, &quot;Bearer $token&quot;)&#10;            } else {&#10;                Log.d(TAG, &quot;No token found; proceeding without Authorization for path: $path&quot;)&#10;            }&#10;        } ?: run {&#10;            Log.d(TAG, &quot;Context null; proceeding without Authorization for path: $path&quot;)&#10;        }&#10;        val newReq = reqBuilder.build()&#10;        // Log headers for debugging (avoid printing token itself)&#10;        val headerNames = newReq.headers.names()&#10;        val headersForLog = headerNames.filter { !it.equals(&quot;Authorization&quot;, true) }&#10;            .joinToString(&quot;,&quot;) { name -&gt; &quot;$name=${newReq.header(name)}&quot; }&#10;        Log.d(TAG, &quot;Request to $path headers=$headersForLog&quot;)&#10;        chain.proceed(newReq)&#10;    }&#10;&#10;    private val okHttpClient = OkHttpClient.Builder()&#10;        .addInterceptor(loggingInterceptor)&#10;        .addInterceptor(stripAuthInterceptor)&#10;        .addInterceptor(authInterceptor)&#10;        .connectTimeout(30, TimeUnit.SECONDS)&#10;        .readTimeout(30, TimeUnit.SECONDS)&#10;        .writeTimeout(30, TimeUnit.SECONDS)&#10;        .build()&#10;&#10;    private val gson = GsonBuilder()&#10;        .setDateFormat(&quot;yyyy-MM-dd'T'HH:mm:ss.SSSZ&quot;)&#10;        .setLenient()&#10;        .create()&#10;&#10;    private val retrofit: Retrofit by lazy {&#10;        Retrofit.Builder()&#10;            .baseUrl(ApiConfig.BASE_URL)&#10;            .client(okHttpClient)&#10;            .addConverterFactory(GsonConverterFactory.create(gson))&#10;            .build()&#10;    }&#10;&#10;    val productoApiService: ProductoApiService by lazy {&#10;        retrofit.create(ProductoApiService::class.java)&#10;    }&#10;&#10;    val categoriaApiService: CategoriaApiService by lazy {&#10;        retrofit.create(CategoriaApiService::class.java)&#10;    }&#10;&#10;    val carritoApiService: CarritoApiService by lazy {&#10;        retrofit.create(CarritoApiService::class.java)&#10;    }&#10;&#10;    val facturaApiService: FacturaApiService by lazy {&#10;        retrofit.create(FacturaApiService::class.java)&#10;    }&#10;&#10;    val stockApiService: StockApiService by lazy {&#10;        retrofit.create(StockApiService::class.java)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/facturacion_inventario/ui/store/CategoryViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/facturacion_inventario/ui/store/CategoryViewModel.kt" />
              <option name="originalContent" value="package com.example.facturacion_inventario.ui.store&#10;&#10;import android.util.Log&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.facturacion_inventario.data.repository.RemoteCategoryRepository&#10;import com.example.facturacion_inventario.data.repository.RemoteProductRepository&#10;import com.example.facturacion_inventario.domain.model.Category&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.async&#10;&#10;/**&#10; * Estados posibles para la carga de categorías&#10; */&#10;sealed class CategoryListState {&#10;    object Loading : CategoryListState()&#10;    data class Success(val categories: List&lt;Category&gt;) : CategoryListState()&#10;    data class Error(val message: String) : CategoryListState()&#10;    object Empty : CategoryListState()&#10;}&#10;&#10;/**&#10; * Estados para el detalle de una categoría&#10; */&#10;sealed class CategoryDetailState {&#10;    object Loading : CategoryDetailState()&#10;    data class Success(val category: Category) : CategoryDetailState()&#10;    data class Error(val message: String) : CategoryDetailState()&#10;}&#10;&#10;/**&#10; * ViewModel para gestionar categorías desde la API real de Spring Boot&#10; * SIN fallback - SOLO usa datos de la API&#10; */&#10;class CategoryViewModel(&#10;    private val repository: RemoteCategoryRepository = RemoteCategoryRepository(),&#10;    private val productRepository: RemoteProductRepository = RemoteProductRepository()&#10;) : ViewModel() {&#10;&#10;    private val TAG = &quot;CategoryViewModel&quot;&#10;&#10;    private val _uiState = MutableStateFlow&lt;CategoryListState&gt;(CategoryListState.Loading)&#10;    val uiState: StateFlow&lt;CategoryListState&gt; = _uiState.asStateFlow()&#10;&#10;    private val _categoryDetail = MutableStateFlow&lt;CategoryDetailState&gt;(CategoryDetailState.Loading)&#10;    @Suppress(&quot;unused&quot;, &quot;MemberVisibilityCanBePrivate&quot;)&#10;    val categoryDetail: StateFlow&lt;CategoryDetailState&gt; = _categoryDetail.asStateFlow()&#10;&#10;    init {&#10;        Log.d(TAG, &quot;CategoryViewModel initialized - loading PUBLIC categories from API...&quot;)&#10;        loadPublicCategories()&#10;    }&#10;&#10;    /**&#10;     * Filtra categorías que tienen al menos un producto&#10;     * @param categories Lista de categorías a filtrar&#10;     * @return Lista de categorías que tienen productos&#10;     */&#10;    private suspend fun filterCategoriesWithProducts(categories: List&lt;Category&gt;): List&lt;Category&gt; {&#10;        Log.d(TAG, &quot; Filtrando categorías con productos...&quot;)&#10;&#10;        // Usar async para consultar todas las categorías en paralelo&#10;        val categoriesWithProducts = categories.mapNotNull { category -&gt;&#10;            viewModelScope.async {&#10;                try {&#10;                    // Consultar productos de esta categoría&#10;                    val result = productRepository.getProductsAsync(categoriaId = category.id)&#10;                    val hasProducts = result.getOrNull()?.isNotEmpty() == true&#10;&#10;                    if (hasProducts) {&#10;                        Log.d(TAG, &quot;  ✅ ${category.name} tiene productos&quot;)&#10;                        category&#10;                    } else {&#10;                        Log.d(TAG, &quot;  ⚠️ ${category.name} NO tiene productos (oculta)&quot;)&#10;                        null&#10;                    }&#10;                } catch (e: Exception) {&#10;                    Log.e(TAG, &quot;  ❌ Error verificando productos de ${category.name}: ${e.message}&quot;)&#10;                    // En caso de error, incluir la categoría por seguridad&#10;                    category&#10;                }&#10;            }&#10;        }.mapNotNull { it.await() }&#10;&#10;        Log.d(TAG, &quot; Resultado: ${categoriesWithProducts.size} de ${categories.size} categorías tienen productos&quot;)&#10;        return categoriesWithProducts&#10;    }&#10;&#10;    /**&#10;     * Carga todas las categorías desde la API (sin fallback a datos locales)&#10;     * Por defecto carga TODAS las categorías (globales + de talleres)&#10;     * NUEVO: Filtra automáticamente categorías sin productos&#10;     */&#10;    fun loadCategories(&#10;        query: String? = null,&#10;        tallerId: String? = null,&#10;        global: Boolean = false,&#10;        todas: Boolean = true,&#10;        page: Int = 0,&#10;        size: Int = 100,&#10;        filterEmpty: Boolean = true // ← NUEVO: Parámetro para filtrar categorías vacías&#10;    ) {&#10;        viewModelScope.launch {&#10;            try {&#10;                _uiState.value = CategoryListState.Loading&#10;                Log.d(TAG, &quot; Loading categories from API&quot;)&#10;                Log.d(TAG, &quot;   Params: query=$query, tallerId=$tallerId, global=$global, todas=$todas, filterEmpty=$filterEmpty&quot;)&#10;&#10;                repository.getCategoriesAsync(&#10;                    query = query,&#10;                    tallerId = tallerId,&#10;                    global = global,&#10;                    todas = todas,&#10;                    page = page,&#10;                    size = size&#10;                ).fold(&#10;                    onSuccess = { categories -&gt;&#10;                        Log.d(TAG, &quot;✅ SUCCESS: Loaded ${categories.size} categories from API&quot;)&#10;&#10;                        // Filtrar categorías sin productos si filterEmpty está activado&#10;                        val finalCategories = if (filterEmpty) {&#10;                            filterCategoriesWithProducts(categories)&#10;                        } else {&#10;                            categories&#10;                        }&#10;&#10;                        finalCategories.forEachIndexed { index, cat -&gt;&#10;                            val tipo = if (cat.tallerId == null) &quot;GLOBAL&quot; else &quot;TALLER(${cat.tallerId})&quot;&#10;                            Log.d(TAG, &quot;  [$index] ${cat.name} - $tipo - ID: ${cat.id}&quot;)&#10;                        }&#10;&#10;                        _uiState.value = if (finalCategories.isEmpty()) {&#10;                            Log.w(TAG, &quot;⚠️ No hay categorías con productos&quot;)&#10;                            CategoryListState.Empty&#10;                        } else {&#10;                            CategoryListState.Success(finalCategories)&#10;                        }&#10;                    },&#10;                    onFailure = { error -&gt;&#10;                        Log.e(TAG, &quot;❌ ERROR loading categories from API: ${error.message}&quot;, error)&#10;                        _uiState.value = CategoryListState.Error(&#10;                            error.message ?: &quot;Error al cargar categorías desde el servidor&quot;&#10;                        )&#10;                    }&#10;                )&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;❌ EXCEPTION in loadCategories: ${e.message}&quot;, e)&#10;                _uiState.value = CategoryListState.Error(&#10;                    &quot;Error inesperado: ${e.message ?: &quot;No se pudo conectar con el servidor&quot;}&quot;&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Carga una categoría específica por ID&#10;     */&#10;    @Suppress(&quot;unused&quot;, &quot;MemberVisibilityCanBePrivate&quot;)&#10;    fun loadCategoryById(id: String) {&#10;        viewModelScope.launch {&#10;            try {&#10;                _categoryDetail.value = CategoryDetailState.Loading&#10;                Log.d(TAG, &quot;Loading category by id: $id&quot;)&#10;&#10;                repository.getCategoryByIdAsync(id).fold(&#10;                    onSuccess = { category -&gt;&#10;                        Log.d(TAG, &quot;Loaded category: ${category.name}&quot;)&#10;                        _categoryDetail.value = CategoryDetailState.Success(category)&#10;                    },&#10;                    onFailure = { error -&gt;&#10;                        Log.e(TAG, &quot;Error loading category from API&quot;, error)&#10;                        _categoryDetail.value = CategoryDetailState.Error(&#10;                            error.message ?: &quot;Error al cargar categoría&quot;&#10;                        )&#10;                    }&#10;                )&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Exception loading category&quot;, e)&#10;                _categoryDetail.value = CategoryDetailState.Error(&#10;                    &quot;Error al cargar la categoría: ${e.message}&quot;&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Busca categorías por nombre&#10;     * NUEVO: También filtra categorías sin productos&#10;     */&#10;    @Suppress(&quot;unused&quot;)&#10;    fun searchCategories(query: String, page: Int = 0, size: Int = 100, filterEmpty: Boolean = true) {&#10;        viewModelScope.launch {&#10;            try {&#10;                _uiState.value = CategoryListState.Loading&#10;                Log.d(TAG, &quot;Searching categories with query: $query&quot;)&#10;&#10;                repository.searchCategories(query, page, size).fold(&#10;                    onSuccess = { categories -&gt;&#10;                        Log.d(TAG, &quot;Found ${categories.size} categories matching '$query'&quot;)&#10;&#10;                        // Filtrar categorías sin productos si filterEmpty está activado&#10;                        val finalCategories = if (filterEmpty) {&#10;                            filterCategoriesWithProducts(categories)&#10;                        } else {&#10;                            categories&#10;                        }&#10;&#10;                        _uiState.value = if (finalCategories.isEmpty()) {&#10;                            CategoryListState.Empty&#10;                        } else {&#10;                            CategoryListState.Success(finalCategories)&#10;                        }&#10;                    },&#10;                    onFailure = { error -&gt;&#10;                        Log.e(TAG, &quot;Error searching categories&quot;, error)&#10;                        _uiState.value = CategoryListState.Error(&#10;                            error.message ?: &quot;Error al buscar categorías&quot;&#10;                        )&#10;                    }&#10;                )&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Exception searching categories&quot;, e)&#10;                _uiState.value = CategoryListState.Error(&quot;Error al buscar: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Reintentar carga&#10;     */&#10;    @Suppress(&quot;unused&quot;)&#10;    fun retry() {&#10;        loadPublicCategories()&#10;    }&#10;&#10;    /**&#10;     * Carga categorías públicas usando el endpoint público (no autenticado)&#10;     */&#10;    fun loadPublicCategories() {&#10;        viewModelScope.launch {&#10;            try {&#10;                _uiState.value = CategoryListState.Loading&#10;                Log.d(TAG, &quot; Loading PUBLIC categories from API&quot;)&#10;&#10;                repository.getPublicCategoriesAsync().fold(&#10;                    onSuccess = { categories -&gt;&#10;                        Log.d(TAG, &quot;✅ SUCCESS: Loaded ${categories.size} PUBLIC categories&quot;)&#10;                        _uiState.value = if (categories.isEmpty()) CategoryListState.Empty else CategoryListState.Success(categories)&#10;                    },&#10;                    onFailure = { error -&gt;&#10;                        Log.e(TAG, &quot;❌ ERROR loading PUBLIC categories: ${error.message}&quot;, error)&#10;                        _uiState.value = CategoryListState.Error(error.message ?: &quot;Error al cargar categorías públicas&quot;)&#10;                    }&#10;                )&#10;&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;❌ EXCEPTION in loadPublicCategories: ${e.message}&quot;, e)&#10;                _uiState.value = CategoryListState.Error(&quot;Error inesperado: ${e.message ?: &quot;No se pudo conectar con el servidor&quot;}&quot;)&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.facturacion_inventario.ui.store&#10;&#10;import android.util.Log&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.facturacion_inventario.data.repository.RemoteCategoryRepository&#10;import com.example.facturacion_inventario.data.repository.RemoteProductRepository&#10;import com.example.facturacion_inventario.domain.model.Category&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.async&#10;&#10;/**&#10; * Estados posibles para la carga de categorías&#10; */&#10;sealed class CategoryListState {&#10;    object Loading : CategoryListState()&#10;    data class Success(val categories: List&lt;Category&gt;) : CategoryListState()&#10;    data class Error(val message: String) : CategoryListState()&#10;    object Empty : CategoryListState()&#10;}&#10;&#10;/**&#10; * Estados para el detalle de una categoría&#10; */&#10;sealed class CategoryDetailState {&#10;    object Loading : CategoryDetailState()&#10;    data class Success(val category: Category) : CategoryDetailState()&#10;    data class Error(val message: String) : CategoryDetailState()&#10;}&#10;&#10;/**&#10; * ViewModel para gestionar categorías desde la API real de Spring Boot&#10; * SIN fallback - SOLO usa datos de la API&#10; */&#10;class CategoryViewModel(&#10;    private val repository: RemoteCategoryRepository = RemoteCategoryRepository(),&#10;    private val productRepository: RemoteProductRepository = RemoteProductRepository()&#10;) : ViewModel() {&#10;&#10;    private val TAG = &quot;CategoryViewModel&quot;&#10;&#10;    private val _uiState = MutableStateFlow&lt;CategoryListState&gt;(CategoryListState.Loading)&#10;    val uiState: StateFlow&lt;CategoryListState&gt; = _uiState.asStateFlow()&#10;&#10;    private val _categoryDetail = MutableStateFlow&lt;CategoryDetailState&gt;(CategoryDetailState.Loading)&#10;    @Suppress(&quot;unused&quot;, &quot;MemberVisibilityCanBePrivate&quot;)&#10;    val categoryDetail: StateFlow&lt;CategoryDetailState&gt; = _categoryDetail.asStateFlow()&#10;&#10;    init {&#10;        Log.d(TAG, &quot;CategoryViewModel initialized - loading PUBLIC categories from API...&quot;)&#10;        loadPublicCategories()&#10;    }&#10;&#10;    /**&#10;     * Filtra categorías que tienen al menos un producto&#10;     * @param categories Lista de categorías a filtrar&#10;     * @return Lista de categorías que tienen productos&#10;     */&#10;    private suspend fun filterCategoriesWithProducts(categories: List&lt;Category&gt;): List&lt;Category&gt; {&#10;        Log.d(TAG, &quot; Filtrando categorías con productos...&quot;)&#10;&#10;        // Usar async para consultar todas las categorías en paralelo&#10;        val categoriesWithProducts = categories.mapNotNull { category -&gt;&#10;            viewModelScope.async {&#10;                try {&#10;                    // Consultar productos de esta categoría (solo 1 item, usar endpoint PUBLIC y cache)&#10;                    val result = productRepository.getPublicProductosAsync(categoriaId = category.id, page = 0, size = 1)&#10;                    val hasProducts = result.getOrNull()?.isNotEmpty() == true&#10;&#10;                    if (hasProducts) {&#10;                        Log.d(TAG, &quot;  ✅ ${category.name} tiene productos&quot;)&#10;                        category&#10;                    } else {&#10;                        Log.d(TAG, &quot;  ⚠️ ${category.name} NO tiene productos (oculta)&quot;)&#10;                        null&#10;                    }&#10;                } catch (e: Exception) {&#10;                    Log.e(TAG, &quot;  ❌ Error verificando productos de ${category.name}: ${e.message}&quot;)&#10;                    // En caso de error, incluir la categoría por seguridad&#10;                    category&#10;                }&#10;            }&#10;        }.mapNotNull { it.await() }&#10;&#10;        Log.d(TAG, &quot; Resultado: ${categoriesWithProducts.size} de ${categories.size} categorías tienen productos&quot;)&#10;        return categoriesWithProducts&#10;    }&#10;&#10;    /**&#10;     * Carga todas las categorías desde la API (sin fallback a datos locales)&#10;     * Por defecto carga TODAS las categorías (globales + de talleres)&#10;     * NUEVO: Filtra automáticamente categorías sin productos&#10;     */&#10;    fun loadCategories(&#10;        query: String? = null,&#10;        tallerId: String? = null,&#10;        global: Boolean = false,&#10;        todas: Boolean = true,&#10;        page: Int = 0,&#10;        size: Int = 100,&#10;        filterEmpty: Boolean = true // ← NUEVO: Parámetro para filtrar categorías vacías&#10;    ) {&#10;        viewModelScope.launch {&#10;            try {&#10;                _uiState.value = CategoryListState.Loading&#10;                Log.d(TAG, &quot; Loading categories from API&quot;)&#10;                Log.d(TAG, &quot;   Params: query=$query, tallerId=$tallerId, global=$global, todas=$todas, filterEmpty=$filterEmpty&quot;)&#10;&#10;                repository.getCategoriesAsync(&#10;                    query = query,&#10;                    tallerId = tallerId,&#10;                    global = global,&#10;                    todas = todas,&#10;                    page = page,&#10;                    size = size&#10;                ).fold(&#10;                    onSuccess = { categories -&gt;&#10;                        Log.d(TAG, &quot;✅ SUCCESS: Loaded ${categories.size} categories from API&quot;)&#10;&#10;                        // Filtrar categorías sin productos si filterEmpty está activado&#10;                        val finalCategories = if (filterEmpty) {&#10;                            filterCategoriesWithProducts(categories)&#10;                        } else {&#10;                            categories&#10;                        }&#10;&#10;                        finalCategories.forEachIndexed { index, cat -&gt;&#10;                            val tipo = if (cat.tallerId == null) &quot;GLOBAL&quot; else &quot;TALLER(${cat.tallerId})&quot;&#10;                            Log.d(TAG, &quot;  [$index] ${cat.name} - $tipo - ID: ${cat.id}&quot;)&#10;                        }&#10;&#10;                        _uiState.value = if (finalCategories.isEmpty()) {&#10;                            Log.w(TAG, &quot;⚠️ No hay categorías con productos&quot;)&#10;                            CategoryListState.Empty&#10;                        } else {&#10;                            CategoryListState.Success(finalCategories)&#10;                        }&#10;                    },&#10;                    onFailure = { error -&gt;&#10;                        Log.e(TAG, &quot;❌ ERROR loading categories from API: ${error.message}&quot;, error)&#10;                        _uiState.value = CategoryListState.Error(&#10;                            error.message ?: &quot;Error al cargar categorías desde el servidor&quot;&#10;                        )&#10;                    }&#10;                )&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;❌ EXCEPTION in loadCategories: ${e.message}&quot;, e)&#10;                _uiState.value = CategoryListState.Error(&#10;                    &quot;Error inesperado: ${e.message ?: &quot;No se pudo conectar con el servidor&quot;}&quot;&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Carga una categoría específica por ID&#10;     */&#10;    @Suppress(&quot;unused&quot;, &quot;MemberVisibilityCanBePrivate&quot;)&#10;    fun loadCategoryById(id: String) {&#10;        viewModelScope.launch {&#10;            try {&#10;                _categoryDetail.value = CategoryDetailState.Loading&#10;                Log.d(TAG, &quot;Loading category by id: $id&quot;)&#10;&#10;                repository.getCategoryByIdAsync(id).fold(&#10;                    onSuccess = { category -&gt;&#10;                        Log.d(TAG, &quot;Loaded category: ${category.name}&quot;)&#10;                        _categoryDetail.value = CategoryDetailState.Success(category)&#10;                    },&#10;                    onFailure = { error -&gt;&#10;                        Log.e(TAG, &quot;Error loading category from API&quot;, error)&#10;                        _categoryDetail.value = CategoryDetailState.Error(&#10;                            error.message ?: &quot;Error al cargar categoría&quot;&#10;                        )&#10;                    }&#10;                )&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Exception loading category&quot;, e)&#10;                _categoryDetail.value = CategoryDetailState.Error(&#10;                    &quot;Error al cargar la categoría: ${e.message}&quot;&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Busca categorías por nombre&#10;     * NUEVO: También filtra categorías sin productos&#10;     */&#10;    @Suppress(&quot;unused&quot;)&#10;    fun searchCategories(query: String, page: Int = 0, size: Int = 100, filterEmpty: Boolean = true) {&#10;        viewModelScope.launch {&#10;            try {&#10;                _uiState.value = CategoryListState.Loading&#10;                Log.d(TAG, &quot;Searching categories with query: $query&quot;)&#10;&#10;                repository.searchCategories(query, page, size).fold(&#10;                    onSuccess = { categories -&gt;&#10;                        Log.d(TAG, &quot;Found ${categories.size} categories matching '$query'&quot;)&#10;&#10;                        // Filtrar categorías sin productos si filterEmpty está activado&#10;                        val finalCategories = if (filterEmpty) {&#10;                            filterCategoriesWithProducts(categories)&#10;                        } else {&#10;                            categories&#10;                        }&#10;&#10;                        _uiState.value = if (finalCategories.isEmpty()) {&#10;                            CategoryListState.Empty&#10;                        } else {&#10;                            CategoryListState.Success(finalCategories)&#10;                        }&#10;                    },&#10;                    onFailure = { error -&gt;&#10;                        Log.e(TAG, &quot;Error searching categories&quot;, error)&#10;                        _uiState.value = CategoryListState.Error(&#10;                            error.message ?: &quot;Error al buscar categorías&quot;&#10;                        )&#10;                    }&#10;                )&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Exception searching categories&quot;, e)&#10;                _uiState.value = CategoryListState.Error(&quot;Error al buscar: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Reintentar carga&#10;     */&#10;    @Suppress(&quot;unused&quot;)&#10;    fun retry() {&#10;        loadPublicCategories()&#10;    }&#10;&#10;    /**&#10;     * Carga categorías públicas usando el endpoint público (no autenticado)&#10;     */&#10;    fun loadPublicCategories() {&#10;        viewModelScope.launch {&#10;            try {&#10;                _uiState.value = CategoryListState.Loading&#10;                Log.d(TAG, &quot; Loading PUBLIC categories from API&quot;)&#10;&#10;                repository.getPublicCategoriesAsync().fold(&#10;                    onSuccess = { categories -&gt;&#10;                        Log.d(TAG, &quot;✅ SUCCESS: Loaded ${categories.size} PUBLIC categories&quot;)&#10;                        _uiState.value = if (categories.isEmpty()) CategoryListState.Empty else CategoryListState.Success(categories)&#10;                    },&#10;                    onFailure = { error -&gt;&#10;                        Log.e(TAG, &quot;❌ ERROR loading PUBLIC categories: ${error.message}&quot;, error)&#10;                        _uiState.value = CategoryListState.Error(error.message ?: &quot;Error al cargar categorías públicas&quot;)&#10;                    }&#10;                )&#10;&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;❌ EXCEPTION in loadPublicCategories: ${e.message}&quot;, e)&#10;                _uiState.value = CategoryListState.Error(&quot;Error inesperado: ${e.message ?: &quot;No se pudo conectar con el servidor&quot;}&quot;)&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/facturacion_inventario/ui/store/ProductViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/facturacion_inventario/ui/store/ProductViewModel.kt" />
              <option name="originalContent" value="package com.example.facturacion_inventario.ui.store&#10;&#10;import android.util.Log&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.facturacion_inventario.data.repository.RemoteProductRepository&#10;import com.example.facturacion_inventario.domain.model.Product&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;&#10;/**&#10; * Estados posibles para la carga de productos&#10; */&#10;sealed class ProductListState {&#10;    object Loading : ProductListState()&#10;    data class Success(val products: List&lt;Product&gt;) : ProductListState()&#10;    data class Error(val message: String) : ProductListState()&#10;    object Empty : ProductListState()&#10;}&#10;&#10;/**&#10; * Estados para el detalle de un producto&#10; */&#10;sealed class ProductDetailState {&#10;    object Loading : ProductDetailState()&#10;    data class Success(val product: Product) : ProductDetailState()&#10;    data class Error(val message: String) : ProductDetailState()&#10;}&#10;&#10;/**&#10; * ViewModel para gestionar la lista de productos desde la API&#10; */&#10;class ProductListViewModel(&#10;    private val repository: RemoteProductRepository = RemoteProductRepository()&#10;) : ViewModel() {&#10;&#10;    private val TAG = &quot;ProductListViewModel&quot;&#10;&#10;    private val _uiState = MutableStateFlow&lt;ProductListState&gt;(ProductListState.Loading)&#10;    val uiState: StateFlow&lt;ProductListState&gt; = _uiState.asStateFlow()&#10;&#10;    init {&#10;        loadProducts()&#10;    }&#10;&#10;    /**&#10;     * Carga todos los productos&#10;     */&#10;    fun loadProducts(categoryId: String? = null, query: String? = null) {&#10;        viewModelScope.launch {&#10;            _uiState.value = ProductListState.Loading&#10;&#10;            repository.getProductsAsync(categoryId, query).fold(&#10;                onSuccess = { products -&gt;&#10;                    Log.d(TAG, &quot;Loaded ${products.size} products successfully&quot;)&#10;                    _uiState.value = if (products.isEmpty()) {&#10;                        ProductListState.Empty&#10;                    } else {&#10;                        ProductListState.Success(products)&#10;                    }&#10;                },&#10;                onFailure = { error -&gt;&#10;                    Log.e(TAG, &quot;Error loading products&quot;, error)&#10;                    _uiState.value = ProductListState.Error(&#10;                        error.message ?: &quot;Error al cargar productos&quot;&#10;                    )&#10;                }&#10;            )&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Busca productos por nombre&#10;     */&#10;    fun searchProducts(query: String) {&#10;        loadProducts(query = query)&#10;    }&#10;&#10;    /**&#10;     * Filtra productos por categoría&#10;     */&#10;    fun filterByCategory(categoryId: String) {&#10;        loadProducts(categoryId = categoryId)&#10;    }&#10;&#10;    /**&#10;     * Reintentar carga&#10;     */&#10;    fun retry() {&#10;        loadProducts()&#10;    }&#10;}&#10;&#10;/**&#10; * ViewModel para gestionar el detalle de un producto&#10; */&#10;class ProductDetailViewModel(&#10;    private val repository: RemoteProductRepository = RemoteProductRepository()&#10;) : ViewModel() {&#10;&#10;    private val TAG = &quot;ProductDetailViewModel&quot;&#10;&#10;    private val _uiState = MutableStateFlow&lt;ProductDetailState&gt;(ProductDetailState.Loading)&#10;    val uiState: StateFlow&lt;ProductDetailState&gt; = _uiState.asStateFlow()&#10;&#10;    /**&#10;     * Carga un producto por ID usando el endpoint público&#10;     */&#10;    fun loadProduct(productId: String) {&#10;        viewModelScope.launch {&#10;            _uiState.value = ProductDetailState.Loading&#10;&#10;            repository.getPublicProductoByIdAsync(productId).fold(&#10;                onSuccess = { product -&gt;&#10;                    Log.d(TAG, &quot;Loaded PUBLIC product: ${product.name} with stock=${product.stock}&quot;)&#10;                    _uiState.value = ProductDetailState.Success(product)&#10;                },&#10;                onFailure = { error -&gt;&#10;                    Log.e(TAG, &quot;Error loading public product&quot;, error)&#10;                    _uiState.value = ProductDetailState.Error(&#10;                        error.message ?: &quot;Error al cargar el producto&quot;&#10;                    )&#10;                }&#10;            )&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Reintentar carga&#10;     */&#10;    fun retry(productId: String) {&#10;        loadProduct(productId)&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.example.facturacion_inventario.ui.store&#10;&#10;import android.util.Log&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.facturacion_inventario.data.repository.RemoteProductRepository&#10;import com.example.facturacion_inventario.domain.model.Product&#10;import com.example.facturacion_inventario.BuildConfig&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;&#10;/**&#10; * Estados posibles para la carga de productos&#10; */&#10;sealed class ProductListState {&#10;    object Loading : ProductListState()&#10;    data class Success(val products: List&lt;Product&gt;) : ProductListState()&#10;    data class Error(val message: String) : ProductListState()&#10;    object Empty : ProductListState()&#10;}&#10;&#10;/**&#10; * Estados para el detalle de un producto&#10; */&#10;sealed class ProductDetailState {&#10;    object Loading : ProductDetailState()&#10;    data class Success(val product: Product) : ProductDetailState()&#10;    data class Error(val message: String) : ProductDetailState()&#10;}&#10;&#10;/**&#10; * ViewModel para gestionar la lista de productos desde la API&#10; */&#10;@Suppress(&quot;MemberVisibilityCanBePrivate&quot;, &quot;unused&quot;)&#10;class ProductListViewModel(&#10;    private val repository: RemoteProductRepository = RemoteProductRepository()&#10;) : ViewModel() {&#10;&#10;    private val TAG = &quot;ProductListViewModel&quot;&#10;&#10;    // Estado público mantenido por compatibilidad con pantallas que usan la API anterior&#10;    private val _uiState = MutableStateFlow&lt;ProductListState&gt;(ProductListState.Loading)&#10;    @Suppress(&quot;unused&quot;)&#10;    val uiState: StateFlow&lt;ProductListState&gt; = _uiState.asStateFlow()&#10;&#10;    // Cache por categoría: cada categoría tiene su MutableStateFlow con la lista de productos&#10;    private val categoryFlows = mutableMapOf&lt;String, MutableStateFlow&lt;List&lt;Product&gt;&gt;&gt;()&#10;&#10;    // Guardar timestamps opcionales para debugging si es necesario&#10;    private val fetchedTimestamps = mutableMapOf&lt;String, Long&gt;()&#10;&#10;    init {&#10;        // Cargar productos generales inicialmente (comportamiento existente)&#10;        loadProducts()&#10;    }&#10;&#10;    /**&#10;     * Devuelve un StateFlow con la lista de productos para una categoría (crea si no existe)&#10;     */&#10;    fun productsForCategoryFlow(categoryId: String): StateFlow&lt;List&lt;Product&gt;&gt; {&#10;        val key = categoryId&#10;        synchronized(categoryFlows) {&#10;            val existing = categoryFlows[key]&#10;            if (existing != null) return existing.asStateFlow()&#10;            val flow = MutableStateFlow&lt;List&lt;Product&gt;&gt;(emptyList())&#10;            categoryFlows[key] = flow&#10;            return flow.asStateFlow()&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Carga productos de la API (general o por categoría). Si ya se cargaron para esa categoría,&#10;     * la función simplemente retorna (no dispara otra petición). Esto evita fetch repetidos desde composables.&#10;     */&#10;    fun fetchProductsByCategory(categoryId: String) {&#10;        val key = categoryId&#10;        val existingFlow = synchronized(categoryFlows) { categoryFlows[key] }&#10;        // Si existe y no está vacío, asumimos que ya lo cargamos recientemente&#10;        if (existingFlow != null &amp;&amp; existingFlow.value.isNotEmpty()) {&#10;            if (BuildConfig.DEBUG) Log.d(TAG, &quot;Skipping fetch for category=$key because cache exists (size=${existingFlow.value.size})&quot;)&#10;            return&#10;        }&#10;&#10;        // Asegurar que el flow existe&#10;        val flow = synchronized(categoryFlows) {&#10;            categoryFlows.getOrPut(key) { MutableStateFlow(emptyList()) }&#10;        }&#10;&#10;        viewModelScope.launch {&#10;            if (BuildConfig.DEBUG) Log.d(TAG, &quot; Fetching PUBLIC products for category=$key from ViewModel&quot;)&#10;            repository.getPublicProductosAsync(categoriaId = categoryId).fold(&#10;                onSuccess = { list -&gt;&#10;                    if (BuildConfig.DEBUG) Log.d(TAG, &quot;✅ Fetched ${list.size} products for category=$key&quot;)&#10;                    flow.value = list&#10;                    fetchedTimestamps[key] = System.currentTimeMillis()&#10;                },&#10;                onFailure = { err -&gt;&#10;                    Log.e(TAG, &quot;❌ Error fetching products for category=$key: ${err.message}&quot;)&#10;                    // En caso de error dejamos la lista vacía para distinguir estado&#10;                    flow.value = emptyList()&#10;                }&#10;            )&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Carga todos los productos (comportamiento previo) — mantiene compatibilidad&#10;     */&#10;    fun loadProducts(categoryId: String? = null, query: String? = null) {&#10;        viewModelScope.launch {&#10;            _uiState.value = ProductListState.Loading&#10;&#10;            repository.getProductsAsync(categoryId, query).fold(&#10;                onSuccess = { products -&gt;&#10;                    if (BuildConfig.DEBUG) Log.d(TAG, &quot;Loaded ${products.size} products successfully&quot;)&#10;                    _uiState.value = if (products.isEmpty()) {&#10;                        ProductListState.Empty&#10;                    } else {&#10;                        ProductListState.Success(products)&#10;                    }&#10;                },&#10;                onFailure = { error -&gt;&#10;                    Log.e(TAG, &quot;Error loading products&quot;, error)&#10;                    _uiState.value = ProductListState.Error(&#10;                        error.message ?: &quot;Error al cargar productos&quot;&#10;                    )&#10;                }&#10;            )&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Busca productos por nombre&#10;     */&#10;    @Suppress(&quot;unused&quot;)&#10;    fun searchProducts(query: String) {&#10;        // Función mantenida por compatibilidad con código legado&#10;        loadProducts(query = query)&#10;    }&#10;&#10;    /**&#10;     * Filtra productos por categoría (mantiene compatibilidad con API existente)&#10;     */&#10;    @Suppress(&quot;unused&quot;)&#10;    fun filterByCategory(categoryId: String) {&#10;        // Compatibilidad con llamadas directas a filtrar&#10;        loadProducts(categoryId = categoryId)&#10;    }&#10;&#10;    /**&#10;     * Reintentar carga&#10;     */&#10;    @Suppress(&quot;unused&quot;)&#10;    fun retry() {&#10;        loadProducts()&#10;    }&#10;}&#10;&#10;/**&#10; * ViewModel para gestionar el detalle de un producto&#10; */&#10;class ProductDetailViewModel(&#10;    private val repository: RemoteProductRepository = RemoteProductRepository()&#10;) : ViewModel() {&#10;&#10;    private val TAG = &quot;ProductDetailViewModel&quot;&#10;&#10;    private val _uiState = MutableStateFlow&lt;ProductDetailState&gt;(ProductDetailState.Loading)&#10;    val uiState: StateFlow&lt;ProductDetailState&gt; = _uiState.asStateFlow()&#10;&#10;    /**&#10;     * Carga un producto por ID usando el endpoint público&#10;     */&#10;    fun loadProduct(productId: String) {&#10;        viewModelScope.launch {&#10;            _uiState.value = ProductDetailState.Loading&#10;&#10;            repository.getPublicProductoByIdAsync(productId).fold(&#10;                onSuccess = { product -&gt;&#10;                    if (BuildConfig.DEBUG) Log.d(TAG, &quot;Loaded PUBLIC product: ${product.name} with stock=${product.stock}&quot;)&#10;                    _uiState.value = ProductDetailState.Success(product)&#10;                },&#10;                onFailure = { error -&gt;&#10;                    Log.e(TAG, &quot;Error loading public product&quot;, error)&#10;                    _uiState.value = ProductDetailState.Error(&#10;                        error.message ?: &quot;Error al cargar el producto&quot;&#10;                    )&#10;                }&#10;            )&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Reintentar carga&#10;     */&#10;    fun retry(productId: String) {&#10;        loadProduct(productId)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/docs/GUIA_CONFIGURACION_ICONO.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/docs/GUIA_CONFIGURACION_ICONO.md" />
              <option name="updatedContent" value="# Guía de Configuración del Ícono Personalizado&#10;&#10;##  Configuración del Ícono ERMOTOS&#10;&#10;Esta guía te ayudará a configurar el ícono personalizado de ERMOTOS en tu aplicación Android.&#10;&#10;## ✅ Lo que ya está configurado&#10;&#10;1. **Archivos XML para Adaptive Icons creados:**&#10;   - `mipmap-anydpi-v26/ic_launcher.xml`&#10;   - `mipmap-anydpi-v26/ic_launcher_round.xml`&#10;&#10;2. **Color de fondo definido en `values/colors.xml`:**&#10;   ```xml&#10;   &lt;color name=&quot;ic_launcher_background&quot;&gt;#FF9800&lt;/color&gt;&#10;   ```&#10;&#10;3. **AndroidManifest.xml ya apunta a `ic_launcher`** (línea 11)&#10;&#10;##  Métodos de Generación de Iconos&#10;&#10;### Método 1: Usar Android Studio (RECOMENDADO) ⭐&#10;&#10;1. Abre Android Studio&#10;2. En el panel izquierdo, navega a: `app/src/main/res`&#10;3. Click derecho en `res` → **New** → **Image Asset**&#10;4. Configura el Asset Studio:&#10;   - **Icon Type:** Launcher Icons (Adaptive and Legacy)&#10;   - **Name:** ic_launcher&#10;   - **Foreground Layer:**&#10;     - Source Asset → **Image**&#10;     - Path → Busca: `app/src/main/res/drawable/ermotoshd.png`&#10;     - Resize → Ajusta al 80-100% (para que no quede muy pequeño)&#10;   - **Background Layer:**&#10;     - Source Asset → **Color**&#10;     - Color → `#FF9800` (naranja de la marca)&#10;5. Click en **Next**&#10;6. Verifica que se generarán archivos en todas las carpetas mipmap&#10;7. Click en **Finish**&#10;&#10;**Ventajas:**&#10;- ✅ Genera automáticamente todas las densidades&#10;- ✅ Crea versiones legacy y adaptive&#10;- ✅ Vista previa en diferentes dispositivos&#10;- ✅ No requiere herramientas externas&#10;&#10;### Método 2: Script Automático (Python)&#10;&#10;Si tienes Python instalado, simplemente ejecuta:&#10;&#10;```batch&#10;cd scripts&#10;generate_icons.bat&#10;```&#10;&#10;El script:&#10;- Verifica si Python está instalado&#10;- Instala Pillow si es necesario&#10;- Genera todos los iconos automáticamente en todas las densidades&#10;&#10;### Método 3: Herramienta Online&#10;&#10;Si prefieres no instalar nada:&#10;&#10;1. Ve a: https://icon.kitchen/ o https://romannurik.github.io/AndroidAssetStudio/&#10;2. Sube el archivo `ermotoshd.png`&#10;3. Ajusta el fondo a color `#FF9800`&#10;4. Descarga el zip generado&#10;5. Extrae los archivos en `app/src/main/res/`&#10;&#10;##  Tamaños Requeridos&#10;&#10;Los iconos deben generarse en estas densidades:&#10;&#10;| Densidad | Tamaño Launcher | Tamaño Foreground |&#10;|----------|----------------|-------------------|&#10;| mdpi     | 48×48 px       | 108×108 px        |&#10;| hdpi     | 72×72 px       | 162×162 px        |&#10;| xhdpi    | 96×96 px       | 216×216 px        |&#10;| xxhdpi   | 144×144 px     | 324×324 px        |&#10;| xxxhdpi  | 192×192 px     | 432×432 px        |&#10;&#10;##  Verificación&#10;&#10;### 1. Verifica que existan estos archivos:&#10;&#10;```&#10;app/src/main/res/&#10;├── mipmap-mdpi/&#10;│   ├── ic_launcher.png&#10;│   ├── ic_launcher_round.png&#10;│   └── ic_launcher_foreground.png&#10;├── mipmap-hdpi/&#10;│   ├── ic_launcher.png&#10;│   ├── ic_launcher_round.png&#10;│   └── ic_launcher_foreground.png&#10;├── mipmap-xhdpi/&#10;│   ├── ic_launcher.png&#10;│   ├── ic_launcher_round.png&#10;│   └── ic_launcher_foreground.png&#10;├── mipmap-xxhdpi/&#10;│   ├── ic_launcher.png&#10;│   ├── ic_launcher_round.png&#10;│   └── ic_launcher_foreground.png&#10;├── mipmap-xxxhdpi/&#10;│   ├── ic_launcher.png&#10;│   ├── ic_launcher_round.png&#10;│   └── ic_launcher_foreground.png&#10;└── mipmap-anydpi-v26/&#10;    ├── ic_launcher.xml&#10;    └── ic_launcher_round.xml&#10;```&#10;&#10;### 2. Verifica el AndroidManifest.xml:&#10;&#10;Debe contener:&#10;```xml&#10;&lt;application&#10;    android:icon=&quot;@mipmap/ic_launcher&quot;&#10;    android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;    ...&gt;&#10;```&#10;&#10;✅ **Ya está configurado correctamente en tu proyecto**&#10;&#10;### 3. Prueba en el emulador/dispositivo:&#10;&#10;```batch&#10;# Limpia el proyecto&#10;.\gradlew clean&#10;&#10;# Compila e instala&#10;.\gradlew installDebug&#10;&#10;# O desde Android Studio: Run &gt; Run 'app'&#10;```&#10;&#10;##  Personalización del Color de Fondo&#10;&#10;Si quieres cambiar el color de fondo del ícono (actualmente `#FF9800`):&#10;&#10;1. Edita `app/src/main/res/values/colors.xml`&#10;2. Cambia el valor de `ic_launcher_background`:&#10;   ```xml&#10;   &lt;color name=&quot;ic_launcher_background&quot;&gt;#TU_COLOR&lt;/color&gt;&#10;   ```&#10;3. Recompila la app&#10;&#10;##  Solución de Problemas&#10;&#10;### El ícono no cambia después de instalar&#10;&#10;1. Desinstala completamente la app:&#10;   ```batch&#10;   adb uninstall com.example.facturacion_inventario&#10;   ```&#10;&#10;2. Vuelve a instalar:&#10;   ```batch&#10;   .\gradlew installDebug&#10;   ```&#10;&#10;3. En algunos launchers, reinicia el dispositivo&#10;&#10;### Los iconos se ven pixelados&#10;&#10;- Asegúrate de que el PNG original (`ermotoshd.png`) tenga al menos 512×512 px&#10;- Usa el método de Android Studio para mejor calidad&#10;- Verifica que estén todas las densidades generadas&#10;&#10;### Error &quot;Resource not found&quot;&#10;&#10;- Verifica que los archivos estén en las carpetas correctas&#10;- Limpia el proyecto: Build → Clean Project&#10;- Reconstruye: Build → Rebuild Project&#10;&#10;##  Resultado Esperado&#10;&#10;Después de completar estos pasos:&#10;- ✅ El ícono de ERMOTOS aparecerá en el launcher&#10;- ✅ Funcionará en Android 5.0+ (legacy icons)&#10;- ✅ Funcionará en Android 8.0+ (adaptive icons con animaciones)&#10;- ✅ Se adaptará a diferentes formas según el launcher del dispositivo&#10;&#10;##  Recursos Adicionales&#10;&#10;- [Guía oficial de iconos de Android](https://developer.android.com/guide/practices/ui_guidelines/icon_design_launcher)&#10;- [Material Design - Product Icons](https://material.io/design/iconography/product-icons.html)&#10;- [Android Asset Studio](https://romannurik.github.io/AndroidAssetStudio/)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/docs/ICONO_QUICK_START.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/docs/ICONO_QUICK_START.md" />
              <option name="updatedContent" value="#  Ícono ERMOTOS - Configuración Completa&#10;&#10;## ✅ Estado Actual del Proyecto&#10;&#10;### Lo que YA está configurado:&#10;&#10;1. ✅ **AndroidManifest.xml** - Configurado para usar `ic_launcher`&#10;   ```xml&#10;   android:icon=&quot;@mipmap/ic_launcher&quot;&#10;   android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;   ```&#10;&#10;2. ✅ **Archivos XML Adaptive Icons** - Creados en `mipmap-anydpi-v26/`&#10;   - `ic_launcher.xml`&#10;   - `ic_launcher_round.xml`&#10;&#10;3. ✅ **Color de fondo** - Definido en `values/colors.xml`&#10;   ```xml&#10;   &lt;color name=&quot;ic_launcher_background&quot;&gt;#FF9800&lt;/color&gt;&#10;   ```&#10;&#10;4. ✅ **Logo original** - Disponible en `drawable/ermotoshd.png`&#10;&#10;---&#10;&#10;##  SIGUIENTE PASO: Generar los Iconos&#10;&#10;Solo falta **generar las imágenes PNG** en todas las densidades. Tienes 3 opciones:&#10;&#10;###  OPCIÓN 1: Android Studio (RECOMENDADO) ⭐&#10;&#10;**La más fácil y confiable**&#10;&#10;```&#10;1. Abre Android Studio&#10;2. Click derecho en res/ → New → Image Asset&#10;3. Configura:&#10;   - Icon Type: Launcher Icons&#10;   - Name: ic_launcher&#10;   - Foreground: Image → drawable/ermotoshd.png&#10;   - Resize: 80-100%&#10;   - Background: Color → #FF9800&#10;4. Next → Finish&#10;```&#10;&#10;**¿Por qué esta opción?**&#10;- ✅ No requiere instalar nada extra&#10;- ✅ Genera todas las densidades automáticamente&#10;- ✅ Vista previa en tiempo real&#10;- ✅ 100% compatible con Android&#10;&#10;---&#10;&#10;###  OPCIÓN 2: Script Automático (Python)&#10;&#10;**Si tienes Python instalado**&#10;&#10;```batch&#10;# Ejecuta en la raíz del proyecto:&#10;cd scripts&#10;CONFIGURAR_ICONO.bat&#10;```&#10;&#10;O directamente:&#10;```batch&#10;cd scripts&#10;generate_icons.bat&#10;```&#10;&#10;**Requisitos:**&#10;- Python 3.x instalado&#10;- El script instala Pillow automáticamente&#10;&#10;---&#10;&#10;###  OPCIÓN 3: Herramienta Online&#10;&#10;**Si no tienes Android Studio ni Python**&#10;&#10;1. Ve a: https://icon.kitchen/&#10;2. Sube `ermotoshd.png`&#10;3. Color de fondo: `#FF9800`&#10;4. Descarga el ZIP&#10;5. Extrae en `app/src/main/res/`&#10;&#10;---&#10;&#10;##  Archivos que se deben generar&#10;&#10;```&#10;app/src/main/res/&#10;├── mipmap-mdpi/&#10;│   ├── ic_launcher.png (48×48)&#10;│   ├── ic_launcher_round.png (48×48)&#10;│   └── ic_launcher_foreground.png (108×108)&#10;├── mipmap-hdpi/&#10;│   ├── ic_launcher.png (72×72)&#10;│   ├── ic_launcher_round.png (72×72)&#10;│   └── ic_launcher_foreground.png (162×162)&#10;├── mipmap-xhdpi/&#10;│   ├── ic_launcher.png (96×96)&#10;│   ├── ic_launcher_round.png (96×96)&#10;│   └── ic_launcher_foreground.png (216×216)&#10;├── mipmap-xxhdpi/&#10;│   ├── ic_launcher.png (144×144)&#10;│   ├── ic_launcher_round.png (144×144)&#10;│   └── ic_launcher_foreground.png (324×324)&#10;└── mipmap-xxxhdpi/&#10;    ├── ic_launcher.png (192×192)&#10;    ├── ic_launcher_round.png (192×192)&#10;    └── ic_launcher_foreground.png (432×432)&#10;```&#10;&#10;---&#10;&#10;##  Verificación&#10;&#10;### Después de generar los iconos:&#10;&#10;1. **Verifica los archivos:**&#10;   ```powershell&#10;   cd scripts&#10;   .\verify_icons.ps1&#10;   ```&#10;&#10;2. **Limpia y recompila:**&#10;   ```batch&#10;   .\gradlew clean&#10;   .\gradlew build&#10;   ```&#10;&#10;3. **Desinstala la app anterior:**&#10;   ```batch&#10;   adb uninstall com.example.facturacion_inventario&#10;   ```&#10;&#10;4. **Instala la nueva versión:**&#10;   ```batch&#10;   .\gradlew installDebug&#10;   ```&#10;   O desde Android Studio: `Run → Run 'app'`&#10;&#10;---&#10;&#10;##  Resultado Esperado&#10;&#10;Cuando esté todo configurado verás:&#10;&#10;- **Android 7.1 y anteriores:** Ícono cuadrado con logo ERMOTOS&#10;- **Android 8.0+:** Ícono adaptativo con:&#10;  - Fondo naranja (#FF9800)&#10;  - Logo ERMOTOS en el frente&#10;  - Se adapta a la forma del launcher (círculo, cuadrado, etc.)&#10;&#10;---&#10;&#10;##  Archivos de Ayuda Creados&#10;&#10;-  **Guía completa:** `docs/GUIA_CONFIGURACION_ICONO.md`&#10;-  **Configuración rápida:** `scripts/CONFIGURAR_ICONO.bat`&#10;-  **Verificador:** `scripts/verify_icons.ps1`&#10;-  **Generador Python:** `scripts/generate_icons.py`&#10;-  **README scripts:** `scripts/README.md`&#10;&#10;---&#10;&#10;##  Ayuda Rápida&#10;&#10;| Problema | Solución |&#10;|----------|----------|&#10;| No veo el nuevo ícono | Desinstala la app completamente y reinstala |&#10;| Iconos pixelados | Usa Android Studio Image Asset |&#10;| Error &quot;Resource not found&quot; | Build → Clean Project → Rebuild |&#10;| El ícono sigue siendo verde | Asegúrate de haber generado todos los PNG |&#10;&#10;---&#10;&#10;##  Resumen en 3 Pasos&#10;&#10;1. ✅ **Ya configurado:** AndroidManifest.xml, XMLs adaptive, color de fondo&#10;2.  **Tú debes hacer:** Generar los PNG con Android Studio Image Asset&#10;3.  **Verificar:** Ejecutar la app y ver el ícono ERMOTOS&#10;&#10;---&#10;&#10;**¡Tu proyecto está 90% listo! Solo falta generar las imágenes PNG.**&#10;&#10;**Recomendación:** Usa Android Studio Image Asset (2 minutos) ⭐&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/docs/NO_OP_COMMENT_TEMPLATE.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/docs/NO_OP_COMMENT_TEMPLATE.md" />
              <option name="updatedContent" value="# Plantilla de Documentación para Funciones No-Op / Placeholder&#10;&#10;##  Plantilla Estándar&#10;&#10;Usar esta plantilla para documentar funciones vacías, no-op o placeholder:&#10;&#10;```kotlin&#10;/**&#10; * ⚠️ FUNCIÓN NO-OP / PLACEHOLDER&#10; * &#10; * PROPÓSITO ORIGINAL:&#10; * [Descripción de para qué fue creada originalmente esta función]&#10; * &#10; * ESTADO ACTUAL:&#10; * [Explicar por qué está vacía o no-op actualmente]&#10; * &#10; * RAZÓN DE MANTENERLA:&#10; * - [ ] Compatibilidad con código existente que la invoca&#10; * - [ ] Diseño futuro planificado&#10; * - [ ] Interfaz/contrato que debe cumplirse&#10; * - [ ] Evitar breaking changes en la API pública&#10; * - [ ] Placeholder para implementación pendiente&#10; * &#10; * CONDICIONES PARA ELIMINACIÓN:&#10; * - [Condición 1: ejemplo: &quot;Cuando se migre completamente a la nueva API&quot;]&#10; * - [Condición 2: ejemplo: &quot;Cuando no haya invocaciones en el código&quot;]&#10; * - [Condición 3: ejemplo: &quot;Después de la versión X.Y.Z&quot;]&#10; * &#10; * IMPLEMENTACIÓN FUTURA (opcional):&#10; * [Descripción de cómo debería implementarse si se decide hacerlo]&#10; * &#10; * @see [Referencias a clases/funciones relacionadas]&#10; * @since [Versión en que se creó]&#10; * @deprecated [Si aplica, indicar desde cuándo y alternativa]&#10; */&#10;@Suppress(&quot;UNUSED_PARAMETER&quot;) // Si tiene parámetros no usados&#10;fun ejemploNoOp(parametro: String) {&#10;    // No-op: Implementación vacía intencionalmente&#10;}&#10;```&#10;&#10;##  Variaciones de la Plantilla&#10;&#10;### Para Funciones Composable No-Op&#10;&#10;```kotlin&#10;/**&#10; * ⚠️ COMPOSABLE NO-OP&#10; * &#10; * PROPÓSITO ORIGINAL: [...]&#10; * ESTADO ACTUAL: [...]&#10; * RAZÓN DE MANTENERLA: [...]&#10; * CONDICIONES PARA ELIMINACIÓN: [...]&#10; */&#10;@Suppress(&quot;UNUSED_PARAMETER&quot;)&#10;@Composable&#10;fun EjemploComposableNoOp(param: Int) {&#10;    // No-op: Renderizado vacío intencionalmente&#10;}&#10;```&#10;&#10;### Para Funciones con Comentario de Implementación Futura&#10;&#10;```kotlin&#10;/**&#10; *  FUNCIÓN PLACEHOLDER - IMPLEMENTACIÓN PENDIENTE&#10; * &#10; * PROPÓSITO: [...]&#10; * ESTADO ACTUAL: Placeholder que no ejecuta lógica&#10; * RAZÓN DE MANTENERLA: Diseño de API definido, implementación pendiente&#10; * CONDICIONES PARA IMPLEMENTACIÓN: [...]&#10; */&#10;fun ejemploPlaceholder() {&#10;    // TODO: Implementar lógica de [descripción]&#10;}&#10;```&#10;&#10;### Para Callbacks Vacíos&#10;&#10;```kotlin&#10;/**&#10; * ⚠️ CALLBACK NO-OP&#10; * &#10; * PROPÓSITO ORIGINAL: [...]&#10; * ESTADO ACTUAL: No ejecuta acción&#10; * RAZÓN: Se mantiene para evitar null checks en el código llamador&#10; * CONDICIONES PARA ELIMINACIÓN: Cuando se implemente el manejo real del evento&#10; */&#10;val onClickNoOp: () -&gt; Unit = { /* No-op callback */ }&#10;```&#10;&#10;##  Ejemplos de Uso&#10;&#10;### Ejemplo 1: Función de Sincronización Deshabilitada&#10;```kotlin&#10;/**&#10; * ⚠️ FUNCIÓN NO-OP&#10; * &#10; * PROPÓSITO ORIGINAL:&#10; * Sincronizar el color de la barra de estado del sistema con el progreso&#10; * del header colapsable para crear una transición visual fluida.&#10; * &#10; * ESTADO ACTUAL:&#10; * Deshabilitada a petición del usuario. No modifica la barra de estado.&#10; * &#10; * RAZÓN DE MANTENERLA:&#10; * - [x] Compatibilidad con código existente que la invoca desde StoreHost&#10; * - [x] Evitar breaking changes (la función se llama en múltiples lugares)&#10; * &#10; * CONDICIONES PARA ELIMINACIÓN:&#10; * - Cuando se refactorice StoreHost y se eliminen todas las invocaciones&#10; * - Después de verificar que no se necesita en ninguna otra pantalla&#10; * - En la próxima versión mayor (breaking changes permitidos)&#10; * &#10; * @param headerProgress Progreso de colapso del header (0f = expandido, 1f = colapsado)&#10; * @param initialColor Color inicial de la barra de estado&#10; * @see StoreHost donde se invoca esta función&#10; * @since v1.0&#10; */&#10;@Suppress(&quot;UNUSED_PARAMETER&quot;)&#10;@Composable&#10;fun StatusBarSync(headerProgress: Float, initialColor: Color = Color(0xFFFFA500)) {&#10;    // No-op: la lógica de modificación de barra de estado ha sido eliminada&#10;}&#10;```&#10;&#10;### Ejemplo 2: Feature No Implementada&#10;```kotlin&#10;/**&#10; *  FUNCIÓN PLACEHOLDER - IMPLEMENTACIÓN PENDIENTE&#10; * &#10; * PROPÓSITO ORIGINAL:&#10; * Permitir la compra directa de un producto sin agregarlo al carrito,&#10; * navegando directamente al checkout con ese único producto.&#10; * &#10; * ESTADO ACTUAL:&#10; * Placeholder sin implementación. El botón existe en la UI pero no ejecuta acción.&#10; * &#10; * RAZÓN DE MANTENERLA:&#10; * - [x] Diseño de UX ya definido (botón visible en ProductDetailScreen)&#10; * - [x] Feature planificada para siguiente sprint&#10; * - [x] Evita tener que modificar la UI más adelante&#10; * &#10; * CONDICIONES PARA IMPLEMENTACIÓN:&#10; * - Cuando se complete la pantalla de Checkout&#10; * - Cuando se implemente el flujo de pago inmediato&#10; * - Sprint 3 según roadmap del proyecto&#10; * &#10; * IMPLEMENTACIÓN FUTURA:&#10; * Debe crear un carrito temporal con el producto seleccionado,&#10; * navegar a la pantalla de checkout y pasar el contexto de &quot;compra rápida&quot;.&#10; * &#10; * @param product Producto a comprar directamente&#10; * @param quantity Cantidad del producto&#10; * @param onComplete Callback al completar la compra&#10; */&#10;fun buyNow(product: Product, quantity: Int, onComplete: () -&gt; Unit) {&#10;    // TODO: Implementar compra directa&#10;    // 1. Crear carrito temporal&#10;    // 2. Navegar a checkout con flag buyNow=true&#10;    // 3. Ejecutar onComplete después de pago exitoso&#10;}&#10;```&#10;&#10;##  Guía de Uso&#10;&#10;1. **Identificar el tipo de función**: No-op, Placeholder, Callback vacío&#10;2. **Copiar la plantilla apropiada**&#10;3. **Completar cada sección**:&#10;   - ✅ PROPÓSITO ORIGINAL: Siempre obligatorio&#10;   - ✅ ESTADO ACTUAL: Explicar claramente por qué está vacía&#10;   - ✅ RAZÓN DE MANTENERLA: Marcar con [x] las que apliquen&#10;   - ✅ CONDICIONES PARA ELIMINACIÓN: Ser específico y medible&#10;4. **Agregar anotaciones relevantes**: `@Suppress`, `@Deprecated`, `@Composable`&#10;5. **Incluir comentario inline**: Breve recordatorio de que es no-op&#10;&#10;## ⚡ Checklist de Calidad&#10;&#10;Antes de considerar la documentación completa, verificar:&#10;&#10;- [ ] ¿Se explica claramente por qué existe la función?&#10;- [ ] ¿Se documenta por qué está vacía actualmente?&#10;- [ ] ¿Las condiciones de eliminación son específicas y medibles?&#10;- [ ] ¿Se agregó `@Suppress` para silenciar warnings relevantes?&#10;- [ ] ¿Hay un comentario inline breve para lectura rápida?&#10;- [ ] ¿Se referenciaron las ubicaciones donde se usa?&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/docs/NO_OP_DOCUMENTATION_SUMMARY.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/docs/NO_OP_DOCUMENTATION_SUMMARY.md" />
              <option name="updatedContent" value="#  Resumen: Documentación de Funciones No-Op y Placeholder&#10;&#10;## ✅ Trabajo Completado&#10;&#10;Se ha documentado correctamente **3 funciones/archivos** con comportamiento no-op o placeholder, aplicando una plantilla estándar de documentación.&#10;&#10;---&#10;&#10;##  Archivos Documentados&#10;&#10;### 1️⃣ **StatusBarSync.kt** - Función No-Op&#10;**Ubicación:** `ui/store/StatusBarSync.kt`&#10;&#10;**Tipo:** ⚠️ COMPOSABLE NO-OP&#10;&#10;**Estado:** &#10;- Función completamente vacía (no ejecuta lógica)&#10;- Se mantiene solo por compatibilidad con StoreHost.kt&#10;&#10;**Propósito Original:**&#10;- Sincronizar color de barra de estado con scroll del header&#10;&#10;**Razones para Mantenerla:**&#10;- ✅ Compatibilidad con código existente&#10;- ✅ Evitar breaking changes&#10;- ✅ Fácil reactivación si se necesita&#10;&#10;**Cuándo Eliminarla:**&#10;- Al refactorizar StoreHost.kt&#10;- En versión mayor (v2.0+)&#10;- Si se decide no sincronizar barra de estado permanentemente&#10;&#10;---&#10;&#10;### 2️⃣ **ProductDetailScreen.kt** - Botón &quot;Comprar Ahora&quot;&#10;**Ubicación:** `ui/screens/ProductDetailScreen.kt` (línea ~101)&#10;&#10;**Tipo:**  BOTÓN PLACEHOLDER - IMPLEMENTACIÓN PENDIENTE&#10;&#10;**Estado:**&#10;- Botón visible en UI pero con onClick vacío&#10;- No ejecuta ninguna acción al hacer clic&#10;&#10;**Propósito Original:**&#10;- Compra directa sin pasar por el carrito (quick buy)&#10;- Navegación inmediata a checkout&#10;&#10;**Razones para Mantenerlo:**&#10;- ✅ Diseño UX ya definido&#10;- ✅ Feature planificada para futuro&#10;- ✅ Patrón común en e-commerce&#10;- ✅ Evita modificar UI después&#10;&#10;**Cuándo Implementarlo:**&#10;- Al completar pantalla de Checkout&#10;- Al definir flujo de &quot;compra rápida&quot;&#10;- Según priorización del backlog&#10;&#10;**Implementación Futura:**&#10;```kotlin&#10;onClick = { &#10;    navController.navigate(&#10;        &quot;${Routes.CHECKOUT}?buyNow=true&amp;productId=${prod.id}&amp;quantity=$selectedQuantity&quot;&#10;    )&#10;}&#10;```&#10;&#10;---&#10;&#10;### 3️⃣ **CartAnimations.kt** - Archivo Completo&#10;**Ubicación:** `ui/store/CartAnimations.kt`&#10;&#10;**Tipo:** ⚠️ ARCHIVO PLACEHOLDER - IMPLEMENTACIÓN PARCIAL NO UTILIZADA&#10;&#10;**Estado:**&#10;- Código completo y funcional&#10;- NO se usa en ninguna pantalla&#10;- Contiene animación &quot;fly to cart&quot; lista para usar&#10;&#10;**Propósito Original:**&#10;- Animación visual de producto volando hacia el carrito&#10;- Mejorar feedback visual al agregar productos&#10;&#10;**Razones para Mantenerlo:**&#10;- ✅ Animación ya implementada y funcional&#10;- ✅ Feature planificada para UX mejorada&#10;- ✅ Evita rehacer trabajo desde cero&#10;- ✅ Código reutilizable&#10;&#10;**Cuándo Implementarlo:**&#10;- Al priorizar mejoras visuales del carrito&#10;- Cuando se quiera feedback más rico&#10;- Requiere integrar coordenadas de producto y carrito&#10;&#10;**Cuándo Eliminarlo:**&#10;- Si se decide no usar &quot;fly to cart&quot;&#10;- Si se opta por otra solución de animación&#10;- Si el peso del código no justifica la feature&#10;&#10;**Uso Futuro:**&#10;```kotlin&#10;var flyingItem by remember { mutableStateOf&lt;FlyingItem?&gt;(null) }&#10;&#10;// Al agregar producto:&#10;flyingItem = FlyingItem(startX, startY, targetX, targetY)&#10;&#10;// En UI:&#10;FlyToCartAnimation(&#10;    flyingItem = flyingItem,&#10;    onAnimationEnd = { flyingItem = null }&#10;)&#10;```&#10;&#10;---&#10;&#10;##  Plantilla Creada&#10;&#10;Se creó el archivo **`docs/NO_OP_COMMENT_TEMPLATE.md`** con:&#10;&#10;✅ **Plantilla estándar reutilizable** para documentar funciones no-op&#10;✅ **Variaciones** para diferentes casos (Composable, Placeholder, Callback)&#10;✅ **Ejemplos de uso** completos y detallados&#10;✅ **Checklist de calidad** para verificar documentación completa&#10;✅ **Guía de uso** paso a paso&#10;&#10;---&#10;&#10;##  Estructura de la Plantilla&#10;&#10;Cada función documentada incluye:&#10;&#10;```kotlin&#10;/**&#10; * ⚠️ [TIPO: NO-OP / PLACEHOLDER / etc.]&#10; * &#10; * PROPÓSITO ORIGINAL:&#10; * [Descripción clara del propósito original]&#10; * &#10; * ESTADO ACTUAL:&#10; * [Por qué está vacía o no se usa]&#10; * &#10; * RAZÓN DE MANTENERLA:&#10; * - [x] Compatibilidad&#10; * - [x] Diseño futuro&#10; * - [x] Evitar breaking changes&#10; * &#10; * CONDICIONES PARA ELIMINACIÓN:&#10; * - [Condición específica y medible]&#10; * - [Cuándo y bajo qué circunstancias]&#10; * &#10; * IMPLEMENTACIÓN FUTURA (opcional):&#10; * [Cómo debería implementarse]&#10; * &#10; * @see [Referencias]&#10; * @since [Versión]&#10; */&#10;@Suppress(&quot;UNUSED_PARAMETER&quot;) // si aplica&#10;fun ejemplo() {&#10;    // No-op: comentario inline breve&#10;}&#10;```&#10;&#10;---&#10;&#10;##  Beneficios Conseguidos&#10;&#10;✅ **Claridad:** Cualquier desarrollador entiende por qué existe el código vacío&#10;✅ **Mantenibilidad:** Condiciones claras para eliminar o implementar&#10;✅ **Consistencia:** Plantilla estándar aplicable a todo el proyecto&#10;✅ **Trazabilidad:** Historial documentado de decisiones de diseño&#10;✅ **Reducción de deuda técnica:** Código no-op identificado y justificado&#10;&#10;---&#10;&#10;##  Próximos Pasos Sugeridos&#10;&#10;1. **Revisar otros archivos** del proyecto buscando más funciones no-op&#10;2. **Aplicar la plantilla** a TODO comentarios sin documentar&#10;3. **Priorizar implementaciones** según documentación de &quot;CONDICIONES&quot;&#10;4. **Refactorizar** funciones que ya cumplan condiciones de eliminación&#10;5. **Actualizar plantilla** si se encuentran nuevos casos de uso&#10;&#10;---&#10;&#10;##  Descripción para Commit&#10;&#10;```&#10;docs(no-op): documentar funciones no-op/placeholder con plantilla estándar&#10;&#10;- Crear plantilla reutilizable en docs/NO_OP_COMMENT_TEMPLATE.md&#10;- Documentar StatusBarSync.kt (composable no-op)&#10;- Documentar botón &quot;Comprar ahora&quot; en ProductDetailScreen&#10;- Documentar CartAnimations.kt (implementado pero no usado)&#10;- Incluir propósito, estado actual, razones y condiciones de eliminación&#10;- Agregar ejemplos de implementación futura&#10;```&#10;&#10;O versión breve:&#10;&#10;```&#10;docs(no-op): documentar funciones vacías con plantilla estándar&#10;&#10;- Crear plantilla docs/NO_OP_COMMENT_TEMPLATE.md&#10;- Documentar StatusBarSync, botón &quot;Comprar ahora&quot; y CartAnimations&#10;- Incluir propósito, razones y condiciones de eliminación&#10;```&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>